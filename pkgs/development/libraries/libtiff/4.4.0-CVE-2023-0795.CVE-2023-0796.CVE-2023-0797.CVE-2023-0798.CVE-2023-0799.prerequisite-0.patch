Based on upstream 9c22495e5eeeae9e00a1596720c969656bb8d678, adjusted for
formatting differences in 4.4.0

diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index 00309b8d..0d61a95e 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -526,7 +526,7 @@ static int rotateContigSamples24bits(uint16_t, uint16_t, uint16_t, uint32_t,
 static int rotateContigSamples32bits(uint16_t, uint16_t, uint16_t, uint32_t,
                                      uint32_t, uint32_t, uint8_t *, uint8_t *);
 static int rotateImage(uint16_t, struct image_data *, uint32_t *, uint32_t *,
-                       unsigned char **);
+                       unsigned char **, size_t *);
 static int mirrorImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,
                        unsigned char *);
 static int invertImage(uint16_t, uint16_t, uint16_t, uint32_t, uint32_t,
@@ -6551,7 +6551,8 @@ static int  correct_orientation(struct image_data *image, unsigned char **work_b
       return (-1);
       }
  
-    if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr))
+        if (rotateImage(rotation, image, &image->width, &image->length,
+                        work_buff_ptr, NULL))
       {
       TIFFError ("correct_orientation", "Unable to rotate image");
       return (-1);
@@ -7775,16 +7776,19 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
 
     if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
       {
+            /* rotateImage() set up a new buffer and calculates its size
+             * individually. Therefore, seg_buffs size  needs to be updated
+             * accordingly. */
+            size_t rot_buf_size = 0;
       if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                      &crop->combined_length, &crop_buff))
+                            &crop->combined_length, &crop_buff, &rot_buf_size))
         {
         TIFFError("processCropSelections", 
                   "Failed to rotate composite regions by %"PRIu32" degrees", crop->rotation);
         return (-1);
         }
       seg_buffs[0].buffer = crop_buff;
-      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)
-                            * image->spp) * crop->combined_length; 
+            seg_buffs[0].size = rot_buf_size;
       }
     }
   else  /* Separated Images */
@@ -7882,11 +7886,17 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
 
       if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
         {
-          /* rotateImage() changes image->width, ->length, ->xres and ->yres, what it schouldn't do here, when more than one section is processed. 
-           * ToDo: Therefore rotateImage() and its usage has to be reworked (e.g. like mirrorImage()) !!
-           */
-	if (rotateImage(crop->rotation, image, &crop->regionlist[i].width, 
-			&crop->regionlist[i].length, &crop_buff))
+                /* rotateImage() changes image->width, ->length, ->xres and
+                 * ->yres, what it schouldn't do here, when more than one
+                 * section is processed. ToDo: Therefore rotateImage() and its
+                 * usage has to be reworked (e.g. like mirrorImage()) !!
+                 * Furthermore, rotateImage() set up a new buffer and calculates
+                 * its size individually. Therefore, seg_buffs size  needs to be
+                 * updated accordingly. */
+                size_t rot_buf_size = 0;
+                if (rotateImage(
+                        crop->rotation, image, &crop->regionlist[i].width,
+                        &crop->regionlist[i].length, &crop_buff, &rot_buf_size))
           {
           TIFFError("processCropSelections", 
                     "Failed to rotate crop region by %"PRIu16" degrees", crop->rotation);
@@ -7897,8 +7907,7 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
         crop->combined_width = total_width;
         crop->combined_length = total_length;
         seg_buffs[i].buffer = crop_buff;
-        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)
-                               * image->spp) * crop->regionlist[i].length; 
+                seg_buffs[i].size = rot_buf_size;
         }
       }  /* for crop->selections loop */
     }  /* Separated Images (else case) */
@@ -8018,7 +8027,7 @@ createCroppedImage(struct image_data *image, struct crop_mask *crop,
   if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */
     {
     if (rotateImage(crop->rotation, image, &crop->combined_width, 
-                    &crop->combined_length, crop_buff_ptr))
+                        &crop->combined_length, crop_buff_ptr, NULL))
       {
       TIFFError("createCroppedImage", 
                 "Failed to rotate image or cropped selection by %"PRIu16" degrees", crop->rotation);
@@ -8679,10 +8688,10 @@ rotateContigSamples32bits(uint16_t rotation, uint16_t spp, uint16_t bps, uint32_
 
 
 /* Rotate an image by a multiple of 90 degrees clockwise */
-static int
-rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width,
-            uint32_t *img_length, unsigned char **ibuff_ptr)
-  {
+static int rotateImage(uint16_t rotation, struct image_data *image,
+                       uint32_t *img_width, uint32_t *img_length,
+                       unsigned char **ibuff_ptr, size_t *rot_buf_size)
+{
   int      shift_width;
   uint32_t   bytes_per_pixel, bytes_per_sample;
   uint32_t   row, rowsize, src_offset, dst_offset;
@@ -8732,6 +8741,8 @@ rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width,
     return (-1);
     }
   _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES);
+    if (rot_buf_size != NULL)
+        *rot_buf_size = buffsize;
 
   ibuff = *ibuff_ptr;
   switch (rotation)
